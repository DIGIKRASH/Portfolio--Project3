<script src="./js/script-min.js"></script>
<!-- <script src="https://code.jquery.com/jquery-3.6.0.js"></script> -->
<!-- <script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/84/three.min.js'></script> -->
<!-- <script src='./locomotive-scroll.min.js'></script> -->
<!-- <script src='./gsap.min.js'></script> -->

<script>
  // (function () {
  //   var scroll = new LocomotiveScroll({
  //     el: document.querySelector('[data-scroll-container]'),
  //     smooth: true,
  //     smoothMobile: false
  //   });
  // })();
  const scroll = new LocomotiveScroll({
    el: document.querySelector('[data-scroll-container]'),
    smooth: true,
    smoothMobile: true
  });
  scroll.destroy();
  document.addEventListener("DOMContentLoaded", function (event) {
    scroll.init();
  });
</script>


<script>
  var WIDTH;
  var HEIGHT;
  var canvas;
  var con;
  var g;
  var pxs = new Array();
  var rint = 60;

  jQuery(document).ready(function () {
    var canvas_particles = jQuery('#particles');
    WIDTH = canvas_particles.width();
    HEIGHT = canvas_particles.height();
    jQuery('#particles').width(WIDTH).height(HEIGHT);
    canvas = document.getElementById('particles');
    jQuery(canvas).attr('width', WIDTH).attr('height', HEIGHT);
    con = canvas.getContext('2d');
    for (var i = 0; i < 500; i++) {
      pxs[i] = new Circle();
      pxs[i].reset();
    }
    setInterval(draw, rint);
  });

  function draw() {
    con.clearRect(0, 0, WIDTH, HEIGHT);
    for (var i = 0; i < pxs.length; i++) {
      pxs[i].fade();
      pxs[i].move();
      pxs[i].draw();
    }
  }

  function Circle() {
    this.s = { ttl: 8000, xmax: 5, ymax: 2, rmax: 3, rt: 1, xdef: 960, ydef: 540, xdrift: 4, ydrift: 4, random: true, blink: true };

    this.reset = function () {
      this.x = (this.s.random ? WIDTH * Math.random() : this.s.xdef);
      this.y = (this.s.random ? HEIGHT * Math.random() : this.s.ydef);
      this.r = ((this.s.rmax - 1) * Math.random()) + 1;
      this.dx = (Math.random() * this.s.xmax) * (Math.random() < .5 ? -1 : 1);
      this.dy = (Math.random() * this.s.ymax) * (Math.random() < .5 ? -1 : 1);
      this.hl = (this.s.ttl / rint) * (this.r / this.s.rmax);
      this.rt = Math.random() * this.hl;
      this.s.rt = Math.random() + 1;
      this.stop = Math.random() * .2 + .4;
      this.s.xdrift *= Math.random() * (Math.random() < .5 ? -1 : 1);
      this.s.ydrift *= Math.random() * (Math.random() < .5 ? -1 : 1);
    }

    this.fade = function () {
      this.rt += this.s.rt;
    }

    this.draw = function () {
      if (this.s.blink && (this.rt <= 0 || this.rt >= this.hl)) this.s.rt = this.s.rt * -1;
      else if (this.rt >= this.hl) this.reset();
      var newo = 1 - (this.rt / this.hl);
      con.beginPath();
      con.arc(this.x, this.y, this.r, 0, Math.PI * 2, true);
      con.closePath();
      var cr = this.r * newo;
      g = con.createRadialGradient(this.x, this.y, 0, this.x, this.y, (cr <= 0 ? 1 : cr));
      g.addColorStop(0.0, 'rgba(255,255,255,' + newo + ')');
      g.addColorStop(this.stop, 'rgba(249,255,232,' + (newo * .6) + ')');
      g.addColorStop(1.0, 'rgba(249,255,232,0)');
      con.fillStyle = g;
      con.fill();
    }

    this.move = function () {
      this.x += (this.rt / this.hl) * this.dx;
      this.y += (this.rt / this.hl) * this.dy;
      if (this.x > WIDTH || this.x < 0) this.dx *= -1;
      if (this.y > HEIGHT || this.y < 0) this.dy *= -1;
    }

    this.getX = function () { return this.x; }
    this.getY = function () { return this.y; }
  }

</script>

<!-- <script>
  var element = document.querySelector('canvas.webgl') || document.body;
  var options = {};

  if (element instanceof HTMLCanvasElement) {
    options.canvas = element;
  }

  var renderer = new THREE.WebGLRenderer(options, { antialias: true });

  if (!options.canvas) {
    element.appendChild(renderer.domElement);
    var canvas = renderer.domElement;
  } else {
    canvas = element;
  }

  // Scene
  var scene = new THREE.Scene();

  // Camera
  camera = new THREE.PerspectiveCamera(75, canvas.clientWidth, canvas.clientHeight, 1, 1000);
  camera.position.z = 500;

  // Fog
  scene.fog = new THREE.Fog(0x222125, 0.001, 360, 1000);

  // Variables
  var particles, particle, particleMaterial, particleCount, points, texture;
  var xSpeed, ySpeed;
  const sizes = {
    width: window.innerWidth,
    height: document.querySelector('body').clientHeight
  }
  // console.log(document.querySelector('body').clientHeight)

  // Speed
  xSpeed = 0.0000001;
  ySpeed = 0.000001;

  // Particles
  particleCount = 35000;
  particles = new THREE.Geometry();

  for (var i = 0; i < particleCount; i++) {
    var px = Math.random() * 2000 - 1000;
    var py = Math.random() * 2000 - 1000;
    var pz = Math.random() * 2000 - 1000;

    particle = new THREE.Vector3(px, py, pz);
    particle.velocity = new THREE.Vector3(0, Math.random(), 0);
    particles.vertices.push(particle);
  }

  var material = new THREE.PointsMaterial({ color: 0xffffff })

  //  // Geometry
  //  const particlesCount = 200
  // const positions = new Float32Array(particlesCount * 3)

  // for (let i = 0; i < particlesCount; i++) {
  //   positions[i * 3 + 0] = (Math.random() - 0.5) * 10
  //   positions[i * 3 + 1] = 4 * 0.5 - Math.random() * objectsDistance * 3
  //   positions[i * 3 + 2] = (Math.random() - 0.5) * 10
  // }

  // const particlesGeometry = new THREE.BufferGeometry()
  // particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3))

  // // Material
  // const particlesMaterial = new THREE.PointsMaterial({
  //   color: '#ffeded',
  //   sizeAttenuation: true,
  //   size: 0.03
  // })

  // // Points
  // const points = new THREE.Points(particlesGeometry, particlesMaterial)
  // scene.add(points)

  // Only for Codepen
  //-------------------------------------

  // Points
  points = new THREE.Points(particles, material);
  points.sortParticles = true;
  scene.add(points);

  // lights
  // var light1, light2, hemiLight;

  // light1 = new THREE.PointLight(0x52ffef, 100, 600);
  // light1.position.set(-200, 300, 300);
  // light1.castShadow = true;
  // light1.shadow.mapSize.width = 2048;
  // light1.shadow.mapSize.height = 2048;
  // scene.add(light1);

  // light2 = new THREE.PointLight(0x53ffd1, 50, 600);
  // light2.position.set(250, -300, 300);
  // light2.castShadow = true;
  // light2.shadow.mapSize.width = 2048;
  // light2.shadow.mapSize.height = 2048;
  // scene.add(light2);

  // hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 5);
  // hemiLight.color.setHSL(0.6, 1, 0.6);
  // hemiLight.groundColor.setHSL(0.095, 1, 0.75);
  // hemiLight.position.set(0, 500, 0);
  // scene.add(hemiLight);

  // Resize
  var resize = function () {
    var width = canvas.clientWidth;
    var height = 3000;
    if (canvas.width != width || canvas.height != height) {
      renderer.setSize(canvas.clientWidth, document.getElementsByTagName('body').clientHeight, false);

      camera.aspect = canvas.clientWidth / document.getElementsByTagName('body').clientHeight;
      camera.updateProjectionMatrix();
    }
    // container = document.getElementsByTagName('body');
    // renderer.setSize(window.clientWidth, document.getElementsByTagName('body').clientHeight);
    // container.appendChild(renderer.domElement);
  };

  // Render
  var render = function () {
    // Call resize
    resize();

    // Animate particles randomly
    var i = particleCount;
    while (i--) {
      var particle = particles.vertices[i];

      // Animate y
      if (particle.y > 1000) {
        particle.y = -1000;
        particle.velocity.y = Math.random();
      }

      particle.velocity.y += Math.random() * ySpeed;
      particle.add(particle.velocity);
    }

    points.geometry.verticesNeedUpdate = true;

    // Points to go upwards
    points.rotation.y += xSpeed;

    // Call scene and camera
    renderer.render(scene, camera);
    // renderer.setSize(sizes.width, sizes.height)

    // Update animation frame
    requestAnimationFrame(render, canvas);
  };

  // Call render
  render();
</script> -->


<!-- <script>
  /**
 * Base
 */
// Canvas
const canvas = document.querySelector('canvas.webgl')

// Scene
const scene = new THREE.Scene()

/**
 * Objects
 */
const objectsDistance = 4

// Material
const material = new THREE.MeshToonMaterial({ color: '#ffeded' })

// Meshes
const mesh1 = new THREE.Mesh(
    new THREE.TorusGeometry(1, 0.4, 16, 60),
    material
)
const mesh2 = new THREE.Mesh(
    new THREE.ConeGeometry(1, 2, 32),
    material
)
const mesh3 = new THREE.Mesh(
    new THREE.TorusKnotGeometry(0.8, 0.35, 100, 16),
    material
)

mesh1.position.y = - objectsDistance * 0
mesh2.position.y = - objectsDistance * 1
mesh3.position.y = - objectsDistance * 2

mesh1.position.x = 2
mesh2.position.x = - 2
mesh3.position.x = 2

const sectionMeshes = [ mesh1, mesh2, mesh3 ]

scene.add(mesh1, mesh2, mesh3)

/**
 * Particles
 */
// Geometry
const particlesCount = 200
const positions = new Float32Array(particlesCount * 3)

for(let i = 0; i < particlesCount; i++)
{
    positions[i * 3 + 0] = (Math.random() - 0.5) * 10
    positions[i * 3 + 1] = objectsDistance * 0.5 - Math.random() * objectsDistance * sectionMeshes.length
    positions[i * 3 + 2] = (Math.random() - 0.5) * 10
}

const particlesGeometry = new THREE.BufferGeometry()
particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3))

// Material
const particlesMaterial = new THREE.PointsMaterial({
    color: '#ffeded',
    sizeAttenuation: true,
    size: 0.03
})

// Points
const particles = new THREE.Points(particlesGeometry, particlesMaterial)
scene.add(particles)

/**
 * Lights
 */
const directionalLight = new THREE.DirectionalLight('#ffffff', 1)
directionalLight.position.set(1, 1, 0)
scene.add(directionalLight)

/**
 * Sizes
 */
const sizes = {
    width: window.innerWidth,
    height: window.innerHeight,
}
console.log(document.querySelector('body').clientHeight)

window.addEventListener('resize', () =>
{
    // Update sizes
    sizes.width = window.innerWidth
    sizes.height = window.innerHeight

    // Update camera
    camera.aspect = sizes.width / sizes.height
    camera.updateProjectionMatrix()

    // Update renderer
    renderer.setSize(sizes.width, sizes.height)
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
})

/**
 * Scroll
 */
let scrollY = window.scrollY
let currentSection = 0

window.addEventListener('scroll', () =>
{
    scrollY = window.scrollY
    const newSection = Math.round(scrollY / sizes.height)

    if(newSection != currentSection)
    {
        currentSection = newSection

        gsap.to(
            sectionMeshes[currentSection].rotation,
            {
                duration: 1.5,
                ease: 'power2.inOut',
                x: '+=6',
                y: '+=3'
            }
        )
    }
})

/**
 * Cursor
 */
const cursor = {}
cursor.x = 0
cursor.y = 0

window.addEventListener('mousemove', (event) =>
{
    cursor.x = event.clientX / sizes.width - 0.5
    cursor.y = event.clientY / sizes.height - 0.5
})

/**
 * Camera
 */
// Group
const cameraGroup = new THREE.Group()
scene.add(cameraGroup)

// Base camera
const camera = new THREE.PerspectiveCamera(35, sizes.width / sizes.height, 0.1, 100)
camera.position.z = 6
cameraGroup.add(camera)

/**
 * Renderer
 */
const renderer = new THREE.WebGLRenderer({
    canvas: canvas,
    alpha: true
})
renderer.setSize(sizes.width, sizes.height)
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))

/**
 * Animate
 */
const clock = new THREE.Clock()
let previousTime = 0

const tick = () =>
{
    const elapsedTime = clock.getElapsedTime()
    const deltaTime = elapsedTime - previousTime
    previousTime = elapsedTime

    // Animate meshes
    for(const mesh of sectionMeshes)
    {
        mesh.rotation.x += deltaTime * 0.1
        mesh.rotation.y += deltaTime * 0.12
    }

    // Animate camera
    camera.position.y = - scrollY / sizes.height * objectsDistance

    const parallaxX = cursor.x * 0.5
    const parallaxY = - cursor.y * 0.5
    
    cameraGroup.position.x += (parallaxX - cameraGroup.position.x) * 5 * deltaTime
    cameraGroup.position.y += (parallaxY - cameraGroup.position.y) * 5 * deltaTime

    // Render
    renderer.render(scene, camera)

    // Call tick again on the next frame
    window.requestAnimationFrame(tick)
}

tick()
</script>  -->